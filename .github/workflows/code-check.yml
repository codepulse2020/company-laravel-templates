name: Reusable Code Check

on:
  workflow_call:
    secrets:
      CI_TEMPLATES_READ_TOKEN:
        description: PAT with read access to the templates repo (used when templates_auth=token)
        required: false
      CI_TEMPLATES_SSH_KEY:
        description: Read-only deploy SSH private key for the templates repo (used when templates_auth=ssh)
        required: false
      OPENAI_API_KEY:
        description: API key for OpenAI used by the ai-review job
        required: false
      AI_RESULT_WEBHOOK_URL:
        description: Optional. Internal API endpoint to receive ai-result.json
        required: false
      AI_RESULT_WEBHOOK_TOKEN:
        description: Optional. Bearer token used to call internal API
        required: false
      SMTP_SERVER:
        description: Optional. SMTP server for sending email reports
        required: false
      SMTP_PORT:
        description: Optional. SMTP port (e.g., 587)
        required: false
      SMTP_USER:
        description: Optional. SMTP username
        required: false
      SMTP_PASS:
        description: Optional. SMTP password
        required: false
      SMTP_FROM:
        description: Optional. From header, e.g., "CI Bot <bot@example.com>"
        required: false
    inputs:
      agents:
        description: "Which checks to run (comma separated)"
        required: false
        type: string
        default: "eslint,unit"
      ai_debug:
        description: "Enable debug: attach diff/context, AI request and raw response"
        required: false
        default: 'true'
        type: string
      role:
        description: "職能類型 (backend/frontend/qa/pm...)"
        required: false
        type: string
        default: "backend"
      ai_backend_rule_modules:
        description: "AI 規則模組，全部後端規則"
        required: false
        type: string
        default: "backend-*"
      ai_frontend_rule_modules:
        description: "AI 規則模組，全部前端規則"
        required: false
        type: string
        default: "frontend-*"
      templates_repo:
        description: "CI templates repo slug (owner/repo)"
        required: false
        type: string
        default: "codepulse2020/company-laravel-templates"
      templates_ref:
        description: "Ref (branch/tag/sha) for templates repo to avoid default-branch lookup"
        required: false
        type: string
        default: "main"
      templates_auth:
        description: "Auth method to checkout templates repo (token|ssh)"
        required: false
        type: string
        default: "token"
      ai_fail_on_violation:
        description: "If true, fail the job when violations are found"
        required: false
        type: string
        default: "false"
      ai_fail_min_severity:
        description: "Minimum severity to fail on (minor|major|critical)"
        required: false
        type: string
        default: "major"
      ai_max_diff_chars:
        description: "Max diff chars to send to AI (large diffs will be truncated)"
        required: false
        type: string
        default: "50000"
      ai_context_mode:
        description: "是否附上『變更檔案在 HEAD 的完整內容』供 AI 參考 (full_changed_files|diff_only)"
        required: false
        type: string
        default: "full_changed_files"
      ai_context_max_files:
        description: "納入上下文的最大檔案數（full_changed_files 模式）"
        required: false
        type: string
        default: "30"
      ai_context_max_chars_per_file:
        description: "每個檔案納入的最大字元數（full_changed_files 模式）"
        required: false
        type: string
        default: "30000"
      # 逐檔審查（分批請求）設定
      ai_per_file_mode:
        description: "逐檔審查模式：off=單次請求（舊行為）| file=逐檔（預設）| hunk=依修改片段（預留）"
        required: false
        type: string
        default: "file"
      ai_per_file_max_files:
        description: "逐檔審查納入的最大檔案數上限"
        required: false
        type: string
        default: "30"
      ai_per_file_max_chunks_per_file:
        description: "單一檔案最多切成幾個區塊送審（避免單次 payload 過大）"
        required: false
        type: string
        default: "3"
      ai_per_file_max_chars_per_chunk:
        description: "每個區塊的字元上限"
        required: false
        type: string
        default: "12000"
      ai_file_extensions:
        description: "僅審查特定副檔名（逗號分隔，空白=不篩選）。例如：php,js,ts"
        required: false
        type: string
        default: "php"
      ai_request_timeout_sec:
        description: "單次 AI 呼叫的逾時秒數（curl 層）"
        required: false
        type: string
        default: "120"
      ai_extra_context:
        description: "當自動收集的 context 為空時，可手動提供額外的上下文（原始程式碼片段或完整檔案內容）"
        required: false
        type: string
        default: ""
      ai_model:
        description: "AI 模型名稱（例如：gpt-5-mini）"
        required: false
        type: string
        default: "gpt-5-mini"
      ai_max_completion_tokens:
        description: "AI 回應最大 tokens 上限（對應新參數 max_completion_tokens）"
        required: false
        type: string
        default: "2000"
      ai_validate_key:
        description: "在執行 AI 稽核前先做健康檢查（確認 OPENAI_API_KEY 與連線可用）"
        required: false
        type: string
        default: "true"
      ai_validation_strict:
        description: "健康檢查失敗時是否直接失敗（true=失敗, false=僅警告）"
        required: false
        type: string
        default: "false"
      ai_annotations:
        description: "是否在工作流輸出 GitHub 註解（error/warning/notice）以標示違規位置"
        required: false
        type: string
        default: "true"
      api_push_result:
        description: "是否將 AI 結果以 API 方式 POST 至內部端點（使用 secrets.AI_RESULT_WEBHOOK_*）"
        required: false
        type: string
        default: "false"
      email_send_result:
        description: "是否以 Email 寄送 AI 結果摘要與附件（使用 SMTP_* secrets）"
        required: false
        type: string
        default: "false"
      email_to:
        description: "Email 收件人（逗號分隔）"
        required: false
        type: string
        default: ""
      email_subject_prefix:
        description: "Email 主旨前綴"
        required: false
        type: string
        default: "AI Review"
      email_from_override:
        description: "覆寫寄件者（未設定則使用 secrets.SMTP_FROM）"
        required: false
        type: string
        default: ""
      # 允許在可重用工作流這裡直接設定 SMTP 參數（不想在各專案設定時）
      smtp_server:
        description: "可選：SMTP 伺服器（優先於 secrets.SMTP_SERVER）"
        required: false
        type: string
        default: "smtp.gmail.com"
      smtp_port:
        description: "可選：SMTP 連接埠（優先於 secrets.SMTP_PORT）"
        required: false
        type: string
        default: "465"
      smtp_user:
        description: "可選：SMTP 使用者（優先於 secrets.SMTP_USER）"
        required: false
        type: string
        default: "codepulse888@gmail.com"
      smtp_pass:
        description: "可選：SMTP 密碼（優先於 secrets.SMTP_PASS；注意安全，建議仍用 Org/Repo Secret）"
        required: false
        type: string
        default: "qfqyhqhdoxxncryg"
      smtp_from:
        description: "可選：預設寄件者（優先於 secrets.SMTP_FROM）"
        required: false
        type: string
        default: "codepulse888@gmail.com"
      # 自動取得收件人
      email_auto_to:
        description: "當 inputs.email_to 為空時，自動從提交/PR 作者取得收件人（true/false）"
        required: false
        type: string
        default: "true"
jobs:
  prepare:
    runs-on: ubuntu-latest
    outputs:
      agents: ${{ steps.set-agents.outputs.agents }}
      role: ${{ steps.set-params.outputs.role }}
      ai_rule_modules: ${{ steps.set-params.outputs.ai_rule_modules }}
    steps:
      - id: set-agents
        run: |
          VALUE="${{ inputs.agents }}"
          VALUE=$(echo "$VALUE" | tr 'A-Z' 'a-z' | tr -d ' ')
          echo "agents=$VALUE" >> $GITHUB_OUTPUT

      - id: set-params
        run: |
          ROLE="${{ inputs.role }}"
          # 根據 role 選擇要使用的規則模組清單
          if [ "$ROLE" = "frontend" ]; then
            AI_RULE_MODULES="${{ inputs.ai_frontend_rule_modules }}"
          else
            AI_RULE_MODULES="${{ inputs.ai_backend_rule_modules }}"
          fi
          echo "role=$ROLE" >> $GITHUB_OUTPUT
          echo "ai_rule_modules=$AI_RULE_MODULES" >> $GITHUB_OUTPUT

  eslint:
    needs: prepare
    if: contains(needs.prepare.outputs.agents, 'eslint')
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
      - run: npm ci
      - run: npm run lint

  unit:
    needs: prepare
    if: contains(needs.prepare.outputs.agents, 'unit')
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
      - run: npm ci
      - run: npm test
      
  ai-review:
    needs: prepare
    if: contains(needs.prepare.outputs.agents, 'ai')
    runs-on: ubuntu-latest

    env:
      ROLE: ${{ needs.prepare.outputs.role }}
      AI_RULE_MODULES: ${{ needs.prepare.outputs.ai_rule_modules }}

    steps:
      # 1. Checkout 專案本身，用來抓 diff
      - name: Checkout target repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install jq
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Validate OpenAI API key and connectivity
        if: ${{ inputs.ai_validate_key == 'true' }}
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        run: |
          STRICT="${{ inputs.ai_validation_strict }}"
          {
            echo "### AI Health Check"
          } >> "$GITHUB_STEP_SUMMARY"

          if [ -z "$OPENAI_API_KEY" ]; then
            {
              echo "- Result: FAIL (OPENAI_API_KEY is missing)"
              echo "> 請在呼叫端 Repo/Org/User 的 Actions Secrets 設定 OPENAI_API_KEY，或將 agents 移除 ai。"
            } >> "$GITHUB_STEP_SUMMARY"
            if [ "$STRICT" = "true" ]; then
              echo "[ai-health] Missing OPENAI_API_KEY" >&2
              exit 1
            else
              exit 0
            fi
          fi

          # 送一個最小請求做健康檢查
          BODY=$(cat <<'EOF'
          {"model":"__MODEL__","max_completion_tokens":1,
           "messages":[{"role":"user","content":"ping"}]}
          EOF
          )
          BODY=${BODY/__MODEL__/${{ inputs.ai_model }}}

          CODE_FILE=$(mktemp)
          RESP_FILE=$(mktemp)
          curl -s -w "%{http_code}" -o "$RESP_FILE" https://api.openai.com/v1/chat/completions \
            -H "Authorization: Bearer $OPENAI_API_KEY" \
            -H "Content-Type: application/json" \
            -d "$BODY" > "$CODE_FILE"
          STATUS=$(cat "$CODE_FILE")
          RAW=$(cat "$RESP_FILE")
          CONTENT=$(echo "$RAW" | jq -r '.choices[0].message.content // empty' 2>/dev/null || true)

          if [ -n "$CONTENT" ] && [ "$STATUS" -lt 400 ]; then
            {
              echo "- HTTP status: ${STATUS}"
              echo "- Result: OK"
            } >> "$GITHUB_STEP_SUMMARY"
          else
            SNIPPET=$(echo "$RAW" | head -c 500)
            {
              echo "- HTTP status: ${STATUS}"
              echo "- Result: FAIL"
              echo "<details><summary>Raw response (first 500 chars)</summary>"
              echo
              echo '```json'
              echo "$SNIPPET"
              echo
              echo '```'
              echo "</details>"
              echo "> 若為 401/403，請確認 API Key 與權限；429 請稍後重試；404/400 請確認模型名稱是否可用。"
            } >> "$GITHUB_STEP_SUMMARY"
            if [ "$STRICT" = "true" ]; then
              exit 1
            fi
          fi

      - name: Get diff vs base (PR/push-aware, robust)
        id: diff
        run: |
          set -e
          EVENT_NAME="${{ github.event_name }}"

          DIFF=""
          BASE_DESC=""
          HEAD_DESC=""

          # Prefer PR base/head when available
          if [ "$EVENT_NAME" = "pull_request" ] || [ "$EVENT_NAME" = "pull_request_target" ]; then
            BASE_SHA="${{ github.event.pull_request.base.sha }}"
            HEAD_SHA="${{ github.event.pull_request.head.sha }}"
            BASE_DESC="$BASE_SHA (PR base)"
            HEAD_DESC="$HEAD_SHA (PR head)"
            git fetch --depth=0 origin "$BASE_SHA" || true
            git fetch --depth=0 origin "$HEAD_SHA" || true
            # Use three-dot to compare against merge-base
            if git merge-base "$HEAD_SHA" "$BASE_SHA" >/dev/null 2>&1 ; then
              DIFF=$(git diff "$BASE_SHA"..."$HEAD_SHA")
            else
              echo "[ai-review] PR SHAs have no merge-base. Falling back to two-dot." >&2
              DIFF=$(git diff "$BASE_SHA".."$HEAD_SHA" || true)
            fi
          else
            # Push or other events: use before/after SHAs if available
            BEFORE_SHA="${{ github.event.before }}"
            AFTER_SHA="${{ github.sha }}"
            if [ -n "$BEFORE_SHA" ] && [ "$BEFORE_SHA" != "0000000000000000000000000000000000000000" ]; then
              BASE_DESC="$BEFORE_SHA (push before)"
              HEAD_DESC="$AFTER_SHA (current)"
              git fetch --depth=0 origin "$BEFORE_SHA" || true
              git fetch --depth=0 origin "$AFTER_SHA" || true
              DIFF=$(git diff "$BEFORE_SHA".."$AFTER_SHA" || true)
            fi

            # If still empty, fallback to default branch logic
            if [ -z "$DIFF" ]; then
              DEFAULT_BRANCH="${{ github.event.repository.default_branch }}"
              if [ -z "$DEFAULT_BRANCH" ]; then
                git remote set-head origin -a >/dev/null 2>&1 || true
                DEFAULT_BRANCH=$(git symbolic-ref --short refs/remotes/origin/HEAD 2>/dev/null | sed 's#^origin/##' || true)
              fi
              if [ -z "$DEFAULT_BRANCH" ]; then
                DEFAULT_BRANCH="main"
              fi
              BASE_DESC="origin/${DEFAULT_BRANCH} (default branch)"
              HEAD_DESC="HEAD"
              git fetch --depth=0 origin "$DEFAULT_BRANCH" || true
              if git merge-base HEAD origin/"$DEFAULT_BRANCH" >/dev/null 2>&1 ; then
                DIFF=$(git diff origin/"$DEFAULT_BRANCH"...HEAD)
              else
                echo "[ai-review] No merge-base with default branch. Falling back to two-dot." >&2
                DIFF=$(git diff origin/"$DEFAULT_BRANCH"..HEAD || true)
                if [ -z "$DIFF" ]; then
                  echo "[ai-review] Final fallback to last commit diff." >&2
                  DIFF=$(git diff HEAD^..HEAD || true)
                fi
              fi
            fi
          fi

          echo "$DIFF" > diff.txt
          JSON_DIFF=$(printf '%s' "$DIFF" | jq -Rs .)
          echo "json_diff=$JSON_DIFF" >> $GITHUB_OUTPUT

          # Outputs for later steps
          DIFF_BYTES=$(wc -c < diff.txt | tr -d ' ')
          if [ "$DIFF_BYTES" -eq 0 ]; then
            echo "diff_empty=true" >> $GITHUB_OUTPUT
          else
            echo "diff_empty=false" >> $GITHUB_OUTPUT
          fi
          echo "base_ref=$BASE_DESC" >> $GITHUB_OUTPUT
          echo "head_ref=$HEAD_DESC" >> $GITHUB_OUTPUT

      - name: Summarize diff
        run: |
          if [ -f diff.txt ]; then
            DIFF_LEN=$(wc -c < diff.txt | tr -d ' ')
            echo "[ai-review] Diff bytes: $DIFF_LEN"
            {
              echo "### AI Review · Diff"
              echo "- Diff size: ${DIFF_LEN} bytes"
              echo "- Base: ${{ steps.diff.outputs.base_ref }}"
              echo "- Head: ${{ steps.diff.outputs.head_ref }}"
              echo "<details><summary>Preview (first 200 chars)</summary>"
              echo
              echo '```diff'
              head -c 200 diff.txt || true
              echo
              echo '```'
              echo "</details>"
              if [ "${{ steps.diff.outputs.diff_empty }}" = "true" ]; then
                echo
                echo "> Diff 為空：這通常表示這次提交相對於基準分支沒有變更，或事件基準偵測失敗。若你確定有變更，請確認 PR base/head 或 push 的 before/after 是否正確。"
              fi
            } >> "$GITHUB_STEP_SUMMARY"
          else
            echo "[ai-review] diff.txt not found; skip summary"
          fi

      # 3.1 由 diff 解析變更檔，收集完整檔案內容作為上下文（可選）
      - name: Build changed files context (full contents)
        id: context
        if: ${{ inputs.ai_context_mode == 'full_changed_files' }}
        run: |
          set -e
          : > changed-files.txt
          : > context.txt
          if [ ! -s diff.txt ]; then
            echo "[ai-review] No diff; skip context build." >&2
            echo "json_context=\"\"" >> $GITHUB_OUTPUT
            echo "context_files=0" >> $GITHUB_OUTPUT
            echo "context_bytes=0" >> $GITHUB_OUTPUT
            exit 0
          fi
          # 從 unified diff 取得變更後的檔名（+++ b/path）
          awk '/^\+\+\+ b\//{print substr($0,7)}' diff.txt | sed 's#\r##' | sort -u > changed-files.txt
          # 若清單為空（例如純刪除），從 diff --git 行取 b/ 檔名
          if [ ! -s changed-files.txt ]; then
            awk '/^diff --git a\//{print $4}' diff.txt | sed 's#^b/##' | sed 's#\r##' | sort -u > changed-files.txt || true
          fi
          MAX_FILES=${{ inputs.ai_context_max_files }}
          MAX_CHARS_PER_FILE=${{ inputs.ai_context_max_chars_per_file }}
          COUNT=0
          while IFS= read -r FILE; do
            [ -z "$FILE" ] && continue
            if [ $COUNT -ge $MAX_FILES ]; then
              echo "[ai-review] Reached ai_context_max_files=$MAX_FILES; stop adding more files." >&2
              break
            fi
            # 只處理 HEAD 仍存在的檔案（忽略刪除檔）
            if git ls-tree -r --name-only HEAD | grep -Fx "$FILE" >/dev/null 2>&1; then
              echo "===== FILE: $FILE (HEAD) =====" >> context.txt
              CONTENT="$(git show HEAD:"$FILE" || true)"
              if [ -n "$CONTENT" ]; then
                LEN=${#CONTENT}
                if [ "$LEN" -gt "$MAX_CHARS_PER_FILE" ]; then
                  printf '%s' "$CONTENT" | head -c "$MAX_CHARS_PER_FILE" >> context.txt
                  printf '\n[TRUNCATED file to %s chars from %s]\n' "$MAX_CHARS_PER_FILE" "$LEN" >> context.txt
                else
                  printf '%s\n' "$CONTENT" >> context.txt
                fi
                echo >> context.txt
                COUNT=$((COUNT+1))
              fi
            fi
          done < changed-files.txt
          TOTAL_BYTES=0
          if [ -f context.txt ]; then
            TOTAL_BYTES=$(wc -c < context.txt | tr -d ' ')
          fi
          CONT_JSON=$(jq -Rs . < context.txt 2>/dev/null || echo '""')
          echo "json_context=$CONT_JSON" >> $GITHUB_OUTPUT
          echo "context_files=$COUNT" >> $GITHUB_OUTPUT
          echo "context_bytes=$TOTAL_BYTES" >> $GITHUB_OUTPUT

      - name: Finalize context output
        id: ctx_out
        run: |
          JSON=${{ steps.context.outputs.json_context }}
          if [ -z "$JSON" ]; then
            JSON="\"\""
          fi
          echo "json=$JSON" >> $GITHUB_OUTPUT

      - name: Summarize context
        if: ${{ inputs.ai_context_mode == 'full_changed_files' }}
        run: |
          FILES=${{ steps.context.outputs.context_files }}
          BYTES=${{ steps.context.outputs.context_bytes }}
          if [ -n "$FILES" ]; then
            {
              echo "### AI Review · Context (full changed files)"
              echo "- Files included: ${FILES}"
              echo "- Total size: ${BYTES} bytes"
              if [ -f context.txt ]; then
                echo "<details><summary>Preview (first 200 chars)</summary>"
                echo
                echo '```text'
                head -c 200 context.txt || true
                echo
                echo '```'
                echo "</details>"
              fi
            } >> "$GITHUB_STEP_SUMMARY"
          fi

      # Decide whether we need to checkout the external templates repo for ai-rules
      - name: Decide rules source
        id: decide
        run: |
          USE_TEMPLATES="false"
          if [ "${{ github.repository }}" = "${{ inputs.templates_repo }}" ]; then
            echo "Running inside templates repo; will use local ai-rules" >&2
          elif [ -d "ai-rules" ]; then
            echo "Local ai-rules found in target repo; skip external checkout" >&2
          else
            USE_TEMPLATES="true"
            echo "No local ai-rules found; will checkout templates repo" >&2
          fi
          echo "use_templates=$USE_TEMPLATES" >> $GITHUB_OUTPUT

      # If we need templates, ensure the selected auth has a secret configured
      - name: Validate templates checkout credentials (with public fallback)
        id: creds
        if: ${{ steps.decide.outputs.use_templates == 'true' }}
        run: |
          AUTH="${{ inputs.templates_auth }}"
          USE_PUBLIC_FALLBACK="false"
          case "$AUTH" in
            token)
              if [ -z "${{ secrets.CI_TEMPLATES_READ_TOKEN }}" ]; then
                echo "CI_TEMPLATES_READ_TOKEN is missing; will try public fallback clone." >&2
                USE_PUBLIC_FALLBACK="true"
              fi
              ;;
            ssh)
              if [ -z "${{ secrets.CI_TEMPLATES_SSH_KEY }}" ]; then
                echo "CI_TEMPLATES_SSH_KEY is missing; will try public fallback clone." >&2
                USE_PUBLIC_FALLBACK="true"
              fi
              ;;
            public)
              echo "templates_auth=public; will use unauthenticated public clone." >&2
              USE_PUBLIC_FALLBACK="true"
              ;;
            *)
              echo "Invalid templates_auth value: '${{ inputs.templates_auth }}'. Expected 'token', 'ssh', or 'public'." >&2
              exit 1
              ;;
          esac
          echo "use_public_fallback=$USE_PUBLIC_FALLBACK" >> $GITHUB_OUTPUT

      # 2. Checkout 共用 CI repo，讀 ai-rules/*.md
      - name: Checkout CI templates repo (token)
        if: ${{ steps.decide.outputs.use_templates == 'true' && inputs.templates_auth == 'token' && steps.creds.outputs.use_public_fallback != 'true' }}
        uses: actions/checkout@v4
        with:
          repository: ${{ inputs.templates_repo }}
          ref: ${{ inputs.templates_ref }}
          token: ${{ secrets.CI_TEMPLATES_READ_TOKEN }}
          path: laravel-templates

      - name: Checkout CI templates repo (ssh)
        if: ${{ steps.decide.outputs.use_templates == 'true' && inputs.templates_auth == 'ssh' && steps.creds.outputs.use_public_fallback != 'true' }}
        uses: actions/checkout@v4
        with:
          repository: ${{ inputs.templates_repo }}
          ref: ${{ inputs.templates_ref }}
          ssh-key: ${{ secrets.CI_TEMPLATES_SSH_KEY }}
          path: laravel-templates

      - name: Public fallback checkout (no credentials)
        if: ${{ steps.decide.outputs.use_templates == 'true' && steps.creds.outputs.use_public_fallback == 'true' }}
        run: |
          set -e
          REPO="${{ inputs.templates_repo }}"
          REF="${{ inputs.templates_ref }}"
          echo "Attempt unauthenticated public clone for $REPO@$REF" >&2
          if [ -d "laravel-templates/ai-rules" ]; then
            echo "laravel-templates/ai-rules already present, skip clone"
            exit 0
          fi
          if command -v git >/dev/null 2>&1; then
            git clone --depth=1 --branch "$REF" "https://github.com/${REPO}.git" laravel-templates || true
          fi
          if [ ! -d "laravel-templates/ai-rules" ]; then
            echo "git clone failed or ai-rules not found, try tarball download" >&2
            mkdir -p _dl && cd _dl
            curl -sSL "https://codeload.github.com/${REPO}/tar.gz/${REF}" -o repo.tgz
            tar xzf repo.tgz
            TOPDIR=$(tar tzf repo.tgz | head -1 | cut -f1 -d"/")
            cd ..
            rm -rf laravel-templates
            mv "_dl/${TOPDIR}" laravel-templates || true
          fi
          if [ ! -d "laravel-templates/ai-rules" ]; then
            echo "Public fallback failed: ai-rules not found in ${REPO}@${REF}" >&2
            exit 1
          fi

      # 3.5 依 diff 產生提示（heuristics hints）協助 AI 聚焦常見問題
      - name: Generate AI hints from diff
        id: hints
        run: |
          set -e
          : > hints.txt
          if [ ! -s diff.txt ]; then
            echo "[ai-review] No diff content for hints." >&2
          else
            echo "# Heuristic hints from diff patterns" >> hints.txt
            echo "" >> hints.txt
            # 常見 Laravel/後端風險模式
            echo "## Potential risky patterns" >> hints.txt
            echo "" >> hints.txt
            grep -nE "\\$request->all\\(|Illuminate\\\\Http\\\\Request|abort\\(|DB::(select|statement|raw)\\(|\\bselect \\* from\\b|->json\\(|Resource::(make|collection)\\(|meta\\.pagination|password|token" diff.txt || true >> hints.txt
            echo "" >> hints.txt
            echo "## Notes" >> hints.txt
            echo "- 注意使用 FormRequest 驗證（避免 Illuminate\\\\Http\\\\Request 與 \$request->all()）。" >> hints.txt
            echo "- 應使用 Resource/Presenter 統一輸出格式，包含 meta.pagination。" >> hints.txt
            echo "- 例外處理與錯誤碼應符合 ExceptionCode 規範，不直接 abort()。" >> hints.txt
          fi
          HINTS_JSON=$(jq -Rs . < hints.txt)
          echo "json_hints=$HINTS_JSON" >> $GITHUB_OUTPUT
          HINTS_BYTES=$(wc -c < hints.txt | tr -d ' ')
          echo "hints_bytes=$HINTS_BYTES" >> $GITHUB_OUTPUT

      - name: Summarize hints
        run: |
          if [ -f hints.txt ]; then
            HINTS_LEN=$(wc -c < hints.txt | tr -d ' ')
            {
              echo "### AI Review · Hints"
              echo "- Hints size: ${HINTS_LEN} bytes"
              echo "<details><summary>Preview (first 200 chars)</summary>"
              echo
              echo '```text'
              head -c 200 hints.txt || true
              echo
              echo '```'
              echo "</details>"
            } >> "$GITHUB_STEP_SUMMARY"
          fi

      # 3. 根據 ai_rule_modules 一個一個把 md 內容串起來
      - name: Build AI rules from modules
        id: rules
        run: |
          if [ -d "laravel-templates/ai-rules" ]; then
            cd laravel-templates
          elif [ -d "ai-rules" ]; then
            echo "Using local ai-rules in current repo"
          else
            echo "ai-rules directory not found in either laravel-templates or current repo" >&2
            exit 1
          fi
          
          RULE_TEXT=""
          
          IFS=',' read -ra MODULE_PATTERNS <<< "$AI_RULE_MODULES"
          for PATTERN in "${MODULE_PATTERNS[@]}"; do
            # 展開通配符合的檔案清單
            MATCHED=0
            for FILE in ai-rules/${PATTERN}.md; do
              if [ -f "$FILE" ]; then
                MODULE_NAME=$(basename "$FILE" .md)
                echo "使用規則模組: $FILE"
                RULE_TEXT="${RULE_TEXT}\n\n===== MODULE: ${MODULE_NAME} =====\n\n$(cat "$FILE")"
                MATCHED=1
              fi
            done
            if [ "$MATCHED" -eq 0 ]; then
              echo "找不到規則模組檔案: ai-rules/${PATTERN}.md，略過"
            fi
          done
          
          # 如果全部都沒找到，就使用存在的預設檔案（改用 backend-main.md）
          if [ -z "$RULE_TEXT" ] && [ -f "ai-rules/backend-main.md" ]; then
            echo "沒有任何模組載入，改用 backend-main.md"
            RULE_TEXT="$(cat ai-rules/backend-main.md)"
          fi
          
          echo -e "$RULE_TEXT" > merged-rules.txt
          JSON_RULES=$(printf '%s' "$RULE_TEXT" | jq -Rs .)
          echo "json_rules=$JSON_RULES" >> $GITHUB_OUTPUT

      - name: Summarize rules
        run: |
          if [ -f merged-rules.txt ]; then
            RULES_LEN=$(wc -c < merged-rules.txt | tr -d ' ')
            echo "[ai-review] Rules bytes: $RULES_LEN"
            {
              echo "### AI Review · Rules"
              echo "- Rules size: ${RULES_LEN} bytes"
              echo "<details><summary>Preview (first 200 chars)</summary>"
              echo
              echo '```markdown'
              head -c 200 merged-rules.txt || true
              echo
              echo '```'
              echo "</details>"
            } >> "$GITHUB_STEP_SUMMARY"
          else
            echo "[ai-review] merged-rules.txt not found; skip summary"
          fi

      - name: Upload AI inputs (artifacts)
        uses: actions/upload-artifact@v4
        with:
          name: ai-review-inputs
          if-no-files-found: ignore
          path: |
            diff.txt
            merged-rules.txt
            hints.txt
            changed-files.txt
            context.txt
            extra-context.txt

      # 4.0 解析 Email 收件人（當 email_to 未提供且允許自動推斷時）
      - name: Resolve email recipients (auto)
        id: email_to
        if: ${{ inputs.email_send_result == 'true' && (inputs.email_to == '' && inputs.email_auto_to == 'true') }}
        run: |
          set -e
          # 預設：從最近 20 筆提交取作者 email，去重後輸出
          git fetch --depth=50 || true
          TO_LIST=$(git log -n 20 --format='%ae' | awk 'NF' | sort -u | paste -sd, -)
          # 若為 PR 事件，也嘗試加入 head commit 的作者
          if [ "${{ github.event_name }}" = "pull_request" ] || [ "${{ github.event_name }}" = "pull_request_target" ]; then
            HEAD_SHA="${{ github.event.pull_request.head.sha }}"
            if [ -n "$HEAD_SHA" ]; then
              H=$(git show -s --format='%ae' "$HEAD_SHA" 2>/dev/null || true)
              if [ -n "$H" ]; then
                if [ -n "$TO_LIST" ]; then TO_LIST="$TO_LIST,$H"; else TO_LIST="$H"; fi
              fi
            fi
          fi
          # 去重整理
          TO_LIST=$(echo "$TO_LIST" | tr ',' '\n' | awk 'NF' | sort -u | paste -sd, -)
          echo "Resolved recipients: $TO_LIST"
          echo "to=$TO_LIST" >> $GITHUB_OUTPUT

      # 4. 呼叫 OpenAI（或你之後自己的 AI）
      # 4.a 逐檔審查（分批請求）
      - name: Per-file AI review (chunked)
        if: ${{ inputs.ai_per_file_mode != 'off' && steps.diff.outputs.diff_empty != 'true' }}
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          RULES_JSON: ${{ steps.rules.outputs.json_rules }}
          HINTS_JSON: ${{ steps.hints.outputs.json_hints }}
        run: |
          set -e
          if [ -z "$OPENAI_API_KEY" ]; then
            echo "OPENAI_API_KEY is not provided. Please add it as a secret in the caller repository or remove 'ai' from 'agents'." >&2
            exit 1
          fi

          # 準備變數與目錄
          MAX_FILES=${{ inputs.ai_per_file_max_files }}
          MAX_CHUNKS=${{ inputs.ai_per_file_max_chunks_per_file }}
          CHUNK_LIMIT=${{ inputs.ai_per_file_max_chars_per_chunk }}
          TIMEOUT=${{ inputs.ai_request_timeout_sec }}
          MODEL='${{ inputs.ai_model }}'
          MAX_COMPLETION='${{ inputs.ai_max_completion_tokens }}'
          EXT_FILTER='${{ inputs.ai_file_extensions }}'

          mkdir -p out/ai
          : > out/ai/_index.tsv

          # 準備規則/提示文字（從 JSON 字串解碼回原文）
          RULES_TEXT=$(printf '%s' "$RULES_JSON" | jq -r . 2>/dev/null || echo "")
          HINTS_TEXT=$(printf '%s' "$HINTS_JSON" | jq -r . 2>/dev/null || echo "")

          # 建立檔名清單（依副檔名篩選，限制數量）
          FILES_ALL=$(cat changed-files.txt 2>/dev/null || true)
          FILES_SEL=""
          COUNT=0
          if [ -n "$FILES_ALL" ]; then
            IFS=$'\n'
            for f in $FILES_ALL; do
              # 副檔名篩選
              if [ -n "$EXT_FILTER" ]; then
                ext=${f##*.}
                echo ",$EXT_FILTER," | tr 'A-Z' 'a-z' | grep -q ",$((echo "$ext" | tr 'A-Z' 'a-z'))," || { continue; }
              fi
              FILES_SEL+="$f\n"
              COUNT=$((COUNT+1))
              if [ $COUNT -ge $MAX_FILES ]; then break; fi
            done
            unset IFS
          fi

          if [ -z "$FILES_SEL" ]; then
            echo "[ai-review] No files selected for per-file review (filter or empty). Skipping." >&2
            # 建立空結果以供後續步驟
            echo '{"violations":[]}' > ai-result.json
            exit 0
          fi

          # 從整體 diff.txt 擷取指定檔案的 diff 片段
          extract_file_diff() {
            local path="$1"
            awk -v p=" $path" '
              /^diff --git / {print_line=0}
              /^diff --git a\// {
                # 檢查本段是否對應到目標檔案
                if ($0 ~ (" diff --git a/" p " b/" p "$")) {print_line=1; print $0; next}
              }
              print_line==1 {print}
            ' diff.txt 2>/dev/null || true
          }

          sanitize() {
            echo "$1" | sed 's/[^A-Za-z0-9._-]/_/g'
          }

          # 初始化結果
          echo '{"violations":[]}' > ai-result.json

          # 逐檔處理
          echo "$FILES_SEL" | sed '/^$/d' | while IFS= read -r FILE; do
            [ -z "$FILE" ] && continue
            SAFE=$(sanitize "$FILE")
            # 取得 HEAD 版本內容
            if ! git show HEAD:"$FILE" > out/ai/$SAFE.full 2>/dev/null; then
              # 檔案可能被刪除，跳過
              continue
            fi

            # 取得該檔 diff 片段
            extract_file_diff "$FILE" > out/ai/$SAFE.diff || true

            # 切 chunk
            CONTENT=$(cat out/ai/$SAFE.full)
            LEN=${#CONTENT}
            if [ "$LEN" -eq 0 ]; then
              continue
            fi
            START=0
            CHUNK_IDX=0
            while [ $START -lt $LEN ] && [ $CHUNK_IDX -lt $MAX_CHUNKS ]; do
              CHUNK=${CONTENT:$START:$CHUNK_LIMIT}
              echo "$CHUNK" > out/ai/$SAFE.chunk.$CHUNK_IDX
              START=$((START+CHUNK_LIMIT))
              CHUNK_IDX=$((CHUNK_IDX+1))
            done

            TOTAL_CHUNKS=$CHUNK_IDX
            IDX=0
            while [ $IDX -lt $TOTAL_CHUNKS ]; do
              CHUNK_TXT=$(cat out/ai/$SAFE.chunk.$IDX)
              # 準備 JSON 參數
              CHUNK_JSON=$(printf '%s' "$CHUNK_TXT" | jq -Rs .)
              DIFF_TXT=$(cat out/ai/$SAFE.diff 2>/dev/null || echo "")
              DIFF_JSON=$(printf '%s' "$DIFF_TXT" | jq -Rs .)

              # 建立請求 JSON（強制 JSON schema 輸出）
              BODY=$(jq -n \
                --arg model "$MODEL" \
                --arg rules "$RULES_TEXT" \
                --arg hints "$HINTS_TEXT" \
                --arg file "$FILE" \
                --arg chunk_txt "$CHUNK_TXT" \
                --arg diff_txt "$DIFF_TXT" \
                --arg sys "你是本公司的後端程式碼 reviewer。請嚴格依照公司規範審查這次變更，並用繁體中文回覆。重要：僅以 JSON 回覆，且必須符合以下 schema：{\n  \"violations\": [\n    {\n      \"rule\": string,\n      \"severity\": \"minor|major|critical\",\n      \"file\": string,\n      \"line\": number|null,\n      \"snippet\": string,\n      \"explanation\": string,\n      \"fix\": string\n    }\n  ]\n}. 嚴禁輸出 Markdown 或多餘文字，僅輸出符合 schema 的 JSON。" \
                --arg maxct "$MAX_COMPLETION" \
                --arg chunk_info "本次審查目標檔案: $FILE；區塊 $(($IDX+1)) / $TOTAL_CHUNKS。請僅回報與此檔案相關之違規，並盡可能標示行號。" \
                '{
                  model: $model,
                  response_format: {
                    type: "json_schema",
                    json_schema: {
                      name: "ai_review_violations",
                      schema: {
                        type: "object",
                        additionalProperties: false,
                        required: ["violations"],
                        properties: {
                          violations: {
                            type: "array",
                            items: {
                              type: "object",
                              additionalProperties: false,
                              required: ["rule", "severity"],
                              properties: {
                                rule: { type: "string" },
                                severity: { type: "string", enum: ["minor","major","critical"] },
                                file: { type: "string" },
                                line: { type: ["integer","null"] },
                                snippet: { type: "string" },
                                explanation: { type: "string" },
                                fix: { type: "string" }
                              }
                            }
                          }
                        }
                      }
                    }
                  },
                  messages: [
                    {role:"system", content:$sys},
                    {role:"system", content:$rules},
                    {role:"user", content:"以下為針對 diff 產生的提示（僅供聚焦可能的問題點）："},
                    {role:"user", content:$hints},
                    {role:"user", content:$chunk_info},
                    {role:"user", content:"以下是該檔案的內容片段（可能截斷）："},
                    {role:"user", content:$chunk_txt},
                    {role:"user", content:"以下是該檔案的 Git diff 片段（若有）："},
                    {role:"user", content:$diff_txt}
                  ],
                  max_completion_tokens: ($maxct|tonumber)
                }')

              # 送出請求
              REQ=out/ai/$SAFE.req.$IDX.json
              RESP=out/ai/$SAFE.resp.$IDX.json
              printf '%s' "$BODY" > "$REQ"
              HTTP_CODE=$(mktemp)
              curl -s --max-time "$TIMEOUT" -w "%{http_code}" -o "$RESP" https://api.openai.com/v1/chat/completions \
                -H "Authorization: Bearer $OPENAI_API_KEY" \
                -H "Content-Type: application/json" \
                -d @"$REQ" > "$HTTP_CODE" || true
              STATUS=$(cat "$HTTP_CODE")
              rm -f "$HTTP_CODE"

              # 解析回應
              CONTENT=$(cat "$RESP" | jq -r '.choices[0].message.content // empty' 2>/dev/null || echo "")
              if [ -n "$CONTENT" ] && echo "$CONTENT" | jq -e . >/dev/null 2>&1; then
                # 合併至總結果
                TMP=$(mktemp)
                printf '%s' "$CONTENT" > "$TMP"
                jq -s '{violations: ( (.[0].violations // []) + (.[1].violations // []) )}' ai-result.json "$TMP" > ai-result.merged.json 2>/dev/null || echo '{"violations":[]}' > ai-result.merged.json
                mv ai-result.merged.json ai-result.json
                rm -f "$TMP"
              else
                echo "[ai-review] Empty or invalid JSON for $FILE chunk $IDX (HTTP $STATUS)" >&2
              fi

              IDX=$((IDX+1))
            done
          done

          # Debug 附件：保留請求與回應
          if [ "${{ inputs.ai_debug }}" = "true" ]; then
            # 打包索引（列出檔案與區塊）
            ls -1 out/ai | sort > out/ai/_files.list || true
          fi

      - name: Call OpenAI for AI review
        if: ${{ inputs.ai_per_file_mode == 'off' && steps.diff.outputs.diff_empty != 'true' }}
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          JSON_CONTEXT: ${{ steps.ctx_out.outputs.json }}
          RULES_JSON: ${{ steps.rules.outputs.json_rules }}
          HINTS_JSON: ${{ steps.hints.outputs.json_hints }}
          EXTRA_CONTEXT: ${{ inputs.ai_extra_context }}
        run: |
          if [ -z "$OPENAI_API_KEY" ]; then
            echo "OPENAI_API_KEY is not provided. Please add it as a secret in the caller repository or remove 'ai' from 'agents'." >&2
            exit 1
          fi

          # Prepare DIFF (as JSON string) with truncation if needed
          MAX_CHARS=${{ inputs.ai_max_diff_chars }}
          DIFF_RAW=$(cat diff.txt)
          DIFF_LEN=${#DIFF_RAW}
          if [ "$DIFF_LEN" -gt "$MAX_CHARS" ]; then
            TRUNCATED=$(printf '%s' "$DIFF_RAW" | head -c "$MAX_CHARS")
            NOTICE="\n\n[TRUNCATED to ${MAX_CHARS} chars from ${DIFF_LEN}]"
            DIFF_JSON=$(printf '%s' "$TRUNCATED$NOTICE" | jq -Rs .)
            DIFF_TRUNCATED="true"
          else
            DIFF_JSON=${{ steps.diff.outputs.json_diff }}
            DIFF_TRUNCATED="false"
          fi

          # Ensure CONTEXT_JSON is a valid JSON string value (already JSON-escaped in env)
          CONTEXT_JSON="$JSON_CONTEXT"
          if [ -z "$CONTEXT_JSON" ]; then
            CONTEXT_JSON="\"\""
          fi

          # Decode JSON-string variables to raw text to pass safely via jq --arg
          RULES_TEXT=$(printf '%s' "$RULES_JSON" | jq -r . 2>/dev/null || echo "")
          HINTS_TEXT=$(printf '%s' "$HINTS_JSON" | jq -r . 2>/dev/null || echo "")
          CONTEXT_TEXT=$(printf '%s' "$CONTEXT_JSON" | jq -r . 2>/dev/null || echo "")
          DIFF_TEXT=$(printf '%s' "$DIFF_JSON" | jq -r . 2>/dev/null || echo "")

          # Summaries for visibility
          {
            echo "### AI Review · Payload inputs"
            echo "- Diff bytes: ${DIFF_LEN} (truncated: ${DIFF_TRUNCATED})"
            if [ -f context.txt ]; then
              CTX_BYTES=$(wc -c < context.txt | tr -d ' ')
            else
              CTX_BYTES=0
            fi
            EXTRA_BYTES=${#EXTRA_CONTEXT}
            echo "- Context bytes (auto-collected): ${CTX_BYTES}"
            echo "- Extra context bytes (manual): ${EXTRA_BYTES}"
          } >> "$GITHUB_STEP_SUMMARY"

          # If both diff and context are effectively empty, skip call
          DIFF_EMPTY="false"
          if [ "$DIFF_LEN" -eq 0 ]; then DIFF_EMPTY="true"; fi
          CTX_EMPTY="false"
          if [ "$CTX_BYTES" -eq 0 ]; then CTX_EMPTY="true"; fi
          USE_EXTRA="false"
          if [ "$CTX_EMPTY" = "true" ] && [ -n "$EXTRA_CONTEXT" ]; then
            # Use provided extra context as fallback and persist for artifacts
            CONTEXT_TEXT="$EXTRA_CONTEXT"
            printf '%s' "$EXTRA_CONTEXT" > extra-context.txt
            USE_EXTRA="true"
          fi
          if [ "$DIFF_EMPTY" = "true" ] && [ "$CTX_EMPTY" = "true" ] && [ -z "$EXTRA_CONTEXT" ]; then
            {
              echo "- Skipping AI call because diff, context, and extra context are all empty."
            } >> "$GITHUB_STEP_SUMMARY"
            exit 0
          fi

          if [ "$USE_EXTRA" = "true" ]; then
            echo "- Using extra context fallback (manual input)." >> "$GITHUB_STEP_SUMMARY"
          fi

          # Build request body with jq using string args to avoid invalid JSON issues
          BODY=$(jq -n \
            --arg model "${{ inputs.ai_model }}" \
            --arg rules "$RULES_TEXT" \
            --arg hints "$HINTS_TEXT" \
            --arg context "${CONTEXT_TEXT:-$CONTEXT_TEXT}" \
            --arg diff "$DIFF_TEXT" \
            --arg sys "你是本公司的後端程式碼 reviewer。請嚴格依照公司規範審查這次變更，並用繁體中文回覆。重要：僅以 JSON 回覆，且必須符合以下 schema：{\n  \"violations\": [\n    {\n      \"rule\": string,            // 觸犯的規則或分類\n      \"severity\": \"minor|major|critical\",\n      \"file\": string,            // 嘗試從 diff 推斷，未知填 \"unknown\"\n      \"line\": number|null,       // 嘗試從 diff 推斷，未知可為 null\n      \"snippet\": string,         // 涉及的片段（可節錄）\n      \"explanation\": string,     // 問題說明與風險\n      \"fix\": string              // 具體修正建議\n    }\n  ]\n}. 嚴禁輸出 Markdown 或多餘文字，僅輸出符合 schema 的 JSON。" \
            --arg maxct "${{ inputs.ai_max_completion_tokens }}" \
            '{
              model: $model,
              response_format: {
                type: "json_schema",
                json_schema: {
                  name: "ai_review_violations",
                  schema: {
                    type: "object",
                    additionalProperties: false,
                    required: ["violations"],
                    properties: {
                      violations: {
                        type: "array",
                        items: {
                          type: "object",
                          additionalProperties: false,
                          required: ["rule", "severity"],
                          properties: {
                            rule: { type: "string" },
                            severity: { type: "string", enum: ["minor","major","critical"] },
                            file: { type: "string" },
                            line: { type: ["integer","null"] },
                            snippet: { type: "string" },
                            explanation: { type: "string" },
                            fix: { type: "string" }
                          }
                        }
                      }
                    }
                  }
                }
              },
              messages: [
                {role:"system", content:$sys},
                {role:"system", content:$rules},
                {role:"user", content:"以下為針對 diff 產生的提示（僅供聚焦可能的問題點）："},
                {role:"user", content:$hints},
                {role:"user", content:"以下是本次變更檔案於 HEAD 的完整內容（可能被截斷）。請將其與 diff 交叉比對以更準確地定位問題（檔名、行號）。若外觀上無明顯變更，仍須檢查是否違反公司規範："},
                {role:"user", content:$context},
                {role:"user", content:"以下是這次變更的 Git diff，請依照上述公司規範指出問題、風險與建議："},
                {role:"user", content:$diff}
              ],
              max_completion_tokens: ($maxct|tonumber)
            }')

          # Save request body if debug enabled
          if [ "${{ inputs.ai_debug }}" = "true" ]; then
            printf '%s' "$BODY" > ai-request.json
          fi

          # Capture HTTP status and body separately for better diagnostics
          HTTP_CODE=$(mktemp)
          RESP_BODY=$(mktemp)
          curl -s -w "%{http_code}" -o "$RESP_BODY" https://api.openai.com/v1/chat/completions \
            -H "Authorization: Bearer $OPENAI_API_KEY" \
            -H "Content-Type: application/json" \
            -d "$BODY" > "$HTTP_CODE"
          STATUS=$(cat "$HTTP_CODE")
          RESPONSE=$(cat "$RESP_BODY")

          # Save raw response if debug enabled
          if [ "${{ inputs.ai_debug }}" = "true" ]; then
            printf '%s' "$RESPONSE" > ai-response.json
          fi

          CONTENT=$(echo "$RESPONSE" | jq -r '.choices[0].message.content // empty')
          if [ -z "$CONTENT" ] || [ "$STATUS" -ge 400 ]; then
            echo "[ai-review] No content returned from OpenAI. Printing raw response snippet for debugging." >&2
            SNIPPET=$(echo "$RESPONSE" | head -c 500)
            {
              echo "### AI Review · Result"
              echo "- HTTP status: ${STATUS}"
              echo "- Status: no content returned from provider"
              echo "<details><summary>Raw response (first 500 chars)</summary>"
              echo
              echo '```json'
              echo "$SNIPPET"
              echo
              echo '```'
              echo "</details>"
              echo
              echo "> 如果你看到空結果：請確認 OPENAI_API_KEY 是否有效、模型名稱是否可用、或稍後重試。"
            } >> "$GITHUB_STEP_SUMMARY"
            exit 0
          else
            if echo "$CONTENT" | jq -e . >/dev/null 2>&1; then
              echo "$CONTENT" > ai-result.json
              VIOLATION_COUNT=$(jq '.violations | length' ai-result.json 2>/dev/null || echo 0)
              CRIT_COUNT=$(jq '[.violations[] | select(.severity=="critical")] | length' ai-result.json 2>/dev/null || echo 0)
              MAJOR_COUNT=$(jq '[.violations[] | select(.severity=="major")] | length' ai-result.json 2>/dev/null || echo 0)
              MINOR_COUNT=$(jq '[.violations[] | select(.severity=="minor")] | length' ai-result.json 2>/dev/null || echo 0)

              {
                echo "### AI Review · Result"
                echo "- Total violations: ${VIOLATION_COUNT}"
                echo "- critical: ${CRIT_COUNT}, major: ${MAJOR_COUNT}, minor: ${MINOR_COUNT}"
                echo "<details><summary>Top violations (up to 10)</summary>"
                echo
                echo '```json'
                jq '{violations: (.violations[:10])}' ai-result.json
                echo '```'
                echo "</details>"
              } >> "$GITHUB_STEP_SUMMARY"

              # Emit GitHub workflow annotations (optional)
              if [ "${{ inputs.ai_annotations }}" = "true" ]; then
                # Limit the number of annotations to avoid noisy logs
                MAX_ANN=50
                COUNT_ANN=0
                jq -c '.violations[]' ai-result.json | while read -r item; do
                  if [ $COUNT_ANN -ge $MAX_ANN ]; then break; fi
                  rule=$(echo "$item" | jq -r '.rule // ""')
                  sev=$(echo "$item" | jq -r '.severity // "major"')
                  file=$(echo "$item" | jq -r '.file // ""')
                  line=$(echo "$item" | jq -r '.line // empty')
                  snippet=$(echo "$item" | jq -r '.snippet // ""' | head -c 300)
                  explain=$(echo "$item" | jq -r '.explanation // ""' | head -c 400)
                  fix=$(echo "$item" | jq -r '.fix // ""' | head -c 400)
                  # Map severity to GitHub levels
                  level="warning"
                  if [ "$sev" = "critical" ]; then level="error"; fi
                  if [ "$sev" = "minor" ]; then level="notice"; fi
                  # Compose message; escape percent, CR, LF for workflow commands
                  msg="[AI] ${rule} - ${explain}"
                  [ -n "$fix" ] && msg="$msg | Fix: $fix"
                  msg=${msg//'%'/'%25'}
                  msg=${msg//$'\r'/'%0D'}
                  msg=${msg//$'\n'/'%0A'}
                  if [ -n "$file" ] && [ -n "$line" ]; then
                    echo "::${level} file=${file},line=${line},col=1::${msg}"
                  elif [ -n "$file" ]; then
                    echo "::${level} file=${file}::${msg}"
                  else
                    echo "::${level}::${msg}"
                  fi
                  COUNT_ANN=$((COUNT_ANN+1))
                done
                if [ $COUNT_ANN -ge $MAX_ANN ]; then
                  echo "[ai-review] Annotation limit reached ($MAX_ANN); remaining findings are in ai-result.json" >&2
                fi
              fi
            else
              echo "[ai-review] Model did not return valid JSON despite instruction. Showing raw content." >&2
              {
                echo "### AI Review · Result"
                echo "- Warning: non-JSON content returned"
                echo '<details><summary>Raw content</summary>'
                echo
                echo '```'
                echo "$CONTENT"
                echo '```'
                echo '</details>'
              } >> "$GITHUB_STEP_SUMMARY"
            fi
          fi

      # 4.1 確保結果檔存在（若模型未回傳內容也建立空結構），便於後續輸出
      - name: Ensure ai-result.json exists
        run: |
          if [ ! -f ai-result.json ]; then
            echo '{"violations":[]}' > ai-result.json
          fi

      - name: Generate heuristic findings and merge with AI result
        run: |
          set -e
          # Build heuristic violations from context.txt if available
          TMP_HEUR=$(mktemp)
          echo '{"violations":[]}' > "$TMP_HEUR"

          if [ -f context.txt ]; then
            FILE=""
            LINE_NO=0
            # We'll parse context.txt which is in the format:
            # ===== FILE: path (HEAD) =====
            # followed by file contents
            awk 'BEGIN{file="";}
                 /^===== FILE: / {
                   # extract file path between marker and (HEAD)
                   match($0, /^===== FILE: (.*) \(HEAD\) =====/, m);
                   if (m[1] != "") {file=m[1];}
                   next;
                 }
                 {print file "\t" NR "\t" $0}' context.txt > __ctx_index.tsv

            gen_entry() {
              local rule="$1"; shift
              local severity="$1"; shift
              local file="$1"; shift
              local line="$1"; shift
              local snippet="$1"; shift
              jq --arg rule "$rule" \
                 --arg sev "$severity" \
                 --arg file "$file" \
                 --argjson line ${line:-null} \
                 --arg snip "$snippet" \
                 '.violations += [{rule:$rule, severity:$sev, file:$file, line:$line, snippet:$snip, explanation:"Heuristic match", fix:"依規範修正"}]' \
                 "$TMP_HEUR" > "$TMP_HEUR.tmp" && mv "$TMP_HEUR.tmp" "$TMP_HEUR"
            }

            # Search for patterns
            while IFS=$'\t' read -r f l t; do
              # skip if file is empty (header not seen yet)
              if [ -z "$f" ]; then continue; fi
              # $request->all(
              if echo "$t" | grep -qE "\$request->all\s*\("; then
                gen_entry "Avoid \$request->all(); use validated()" "major" "$f" "$l" "$t"
              fi
              # Illuminate\\Http\\Request typehint or use
              if echo "$t" | grep -qE "Illuminate\\\\Http\\\\Request"; then
                gen_entry "Controller should use FormRequest instead of Illuminate\\Http\\Request" "major" "$f" "$l" "$t"
              fi
              # abort(
              if echo "$t" | grep -qE "\babort\s*\("; then
                gen_entry "Avoid direct abort(); use domain exceptions with handler" "minor" "$f" "$l" "$t"
              fi
              # DB::raw(
              if echo "$t" | grep -qE "DB::raw\s*\("; then
                gen_entry "Avoid DB::raw unless sanitized; prefer query builder/params" "major" "$f" "$l" "$t"
              fi
            done < __ctx_index.tsv
          fi

          # Merge heuristic results into ai-result.json (de-duplicate by file+line+rule basic)
          if [ -s "$TMP_HEUR" ]; then
            jq -s 'def key(v): ((v.file // "") + ":" + ((v.line|tostring) // "") + ":" + (v.rule // ""));
                   {violations: ( (.[0].violations // []) + (.[1].violations // []) )
                     | reduce .[] as $v ( [] ; 
                         (.[key($v)]? // null) as $k |
                         if $k==null then . + [$v] | .[key($v)]=1 else . end ) ) } 
                   | {violations: map(delpaths([["__key"]])) }' \
              ai-result.json "$TMP_HEUR" > ai-result.merged.json || echo '{"violations":[]}' > ai-result.merged.json
            mv ai-result.merged.json ai-result.json
          fi

          # Append heuristic summary to Step Summary
          if [ -f ai-result.json ]; then
            V_TOTAL=$(jq '.violations|length' ai-result.json 2>/dev/null || echo 0)
            V_CRIT=$(jq '[.violations[]|select(.severity=="critical")]|length' ai-result.json 2>/dev/null || echo 0)
            V_MAJ=$(jq '[.violations[]|select(.severity=="major")]|length' ai-result.json 2>/dev/null || echo 0)
            V_MIN=$(jq '[.violations[]|select(.severity=="minor")]|length' ai-result.json 2>/dev/null || echo 0)
            {
              echo "### AI Review · Heuristic Merge"
              echo "- Total after merge: ${V_TOTAL} (critical=${V_CRIT}, major=${V_MAJ}, minor=${V_MIN})"
            } >> "$GITHUB_STEP_SUMMARY"
          fi

      - name: Render Markdown report (ai-report.md)
        run: |
          set -e
          TOTAL=$(jq '.violations|length' ai-result.json 2>/dev/null || echo 0)
          CRIT=$(jq '[.violations[]|select(.severity=="critical")]|length' ai-result.json 2>/dev/null || echo 0)
          MAJ=$(jq '[.violations[]|select(.severity=="major")]|length' ai-result.json 2>/dev/null || echo 0)
          MIN=$(jq '[.violations[]|select(.severity=="minor")]|length' ai-result.json 2>/dev/null || echo 0)
          {
            echo '# AI 稽核結果'
            echo
            echo "- Total: ${TOTAL}"
            echo "- critical: ${CRIT}, major: ${MAJ}, minor: ${MIN}"
            echo
          } > ai-report.md
          if [ "$TOTAL" -eq 0 ]; then
            {
              echo '> 沒有發現違規項目。可能原因：'
              echo '- 這次 diff 幾乎為空或僅包含非程式檔案'
              echo '- 規則沒有命中（可調整規則或提高上下文上限）'
              echo '- 模型回應為空或受限（請見工作流 Summary 的 Raw response 訊息）'
            } >> ai-report.md
          else
            # 列出前 50 筆違規
            jq -r '
              def sev: ( ( .severity // "" ) | ascii_downcase ) as $s
                | ( $s == "critical" and "CRITICAL" or ($s == "major" and "MAJOR" or ($s == "minor" and "MINOR" or ( .severity // "" ))) );
              def line(v): if v==null then "" else ":" + (v|tostring) end;
              def snip(v): if (v|tostring) == "" then "" else "\n```\n" + (v|tostring)[0:800] + "\n```\n" end;
              .violations[:50]
              | to_entries[]
              | "\n## " + ((.key+1)|tostring) + ". " + ( {severity:.value}|.value|sev ) + " - " + (.value.rule // "") + "\n"
                + ( if (.value.file // "") != "" then "- file: `" + (.value.file) + "`" + line(.value.line) + "\n" else "" end )
                + snip(.value.snippet)
                + ( if (.value.explanation // "") != "" then "- explanation: " + (.value.explanation|tostring) + "\n" else "" end )
                + ( if (.value.fix // "") != "" then "- fix: " + (.value.fix|tostring) + "\n" else "" end )
            ' ai-result.json >> ai-report.md
          fi

      - name: Prepare email body from ai-report.md
        id: email_md
        run: |
          {
            echo 'body<<EOF'
            cat ai-report.md
            echo EOF
          } >> "$GITHUB_OUTPUT"

      # 4.2 上傳結果為 artifact，方便離線存取
      - name: Upload AI result (artifact)
        uses: actions/upload-artifact@v4
        with:
          name: ai-review-result
          if-no-files-found: ignore
          path: |
            ai-result.json

      - name: Upload AI debug bundle (artifact)
        if: ${{ inputs.ai_debug == 'true' }}
        uses: actions/upload-artifact@v4
        with:
          name: ai-review-debug
          if-no-files-found: ignore
          path: |
            diff.txt
            context.txt
            extra-context.txt
            merged-rules.txt
            hints.txt
            ai-request.json
            ai-response.json

      - name: Build email attachments list
        id: attachments
        run: |
          {
            echo 'list<<EOF'
            echo 'ai-result.json'
            echo 'ai-report.md'
            if [ "${{ inputs.ai_debug }}" = "true" ]; then
              [ -f diff.txt ] && echo 'diff.txt'
              [ -f context.txt ] && echo 'context.txt'
              [ -f extra-context.txt ] && echo 'extra-context.txt'
              [ -f merged-rules.txt ] && echo 'merged-rules.txt'
              [ -f hints.txt ] && echo 'hints.txt'
              [ -f ai-request.json ] && echo 'ai-request.json'
              [ -f ai-response.json ] && echo 'ai-response.json'
            fi
            echo 'EOF'
          } >> "$GITHUB_OUTPUT"

      # 4.3 以 API 方式將結果送至內部系統
      - name: Push AI result to internal API
        if: ${{ inputs.api_push_result == 'true' }}
        env:
          HOOK_URL: ${{ secrets.AI_RESULT_WEBHOOK_URL }}
          HOOK_TOKEN: ${{ secrets.AI_RESULT_WEBHOOK_TOKEN }}
        run: |
          if [ -z "$HOOK_URL" ]; then
            echo "[ai-review] AI_RESULT_WEBHOOK_URL is not set; skip API push." >&2
            exit 0
          fi
          # 帶 Bearer token（若有）
          if [ -n "$HOOK_TOKEN" ]; then
            AUTH_HEADER="Authorization: Bearer $HOOK_TOKEN"
          else
            AUTH_HEADER=""
          fi
          echo "[ai-review] POST ai-result.json to $HOOK_URL" >&2
          curl -sS -X POST "$HOOK_URL" \
            -H "$AUTH_HEADER" \
            -H "Content-Type: application/json" \
            --data-binary @ai-result.json \
            -o /tmp/hook_resp.txt -w "HTTP:%{http_code}\n" || true
          echo "[ai-review] Hook response (first 200 chars):" >&2
          head -c 200 /tmp/hook_resp.txt || true

      # 4.4 準備 Email 內容（摘要），供寄送步驟使用
      - name: Prepare email summary
        id: email_prep
        if: ${{ inputs.email_send_result == 'true' }}
        run: |
          VIOLATIONS=$(jq '.violations | length' ai-result.json 2>/dev/null || echo 0)
          CRIT=$(jq '[.violations[]|select(.severity=="critical")] | length' ai-result.json 2>/dev/null || echo 0)
          MAJ=$(jq '[.violations[]|select(.severity=="major")] | length' ai-result.json 2>/dev/null || echo 0)
          MIN=$(jq '[.violations[]|select(.severity=="minor")] | length' ai-result.json 2>/dev/null || echo 0)
          BODY="Repo: ${GITHUB_REPOSITORY}\nCommit: ${GITHUB_SHA}\nTotal violations: ${VIOLATIONS} (critical=${CRIT}, major=${MAJ}, minor=${MIN})\n\n前 5 筆：\n$(jq -r '[.violations[:5][] | "- [\(.severity)] \(.rule) @ \(.file // "unknown"):\(.line // "")" ] | join("\n")' ai-result.json 2>/dev/null)"
          # 將換行與百分比做跳脫以便輸出
          BODY_ESC=${BODY//'%'/'%25'}
          BODY_ESC=${BODY_ESC//$'\n'/'%0A'}
          BODY_ESC=${BODY_ESC//$'\r'/'%0D'}
          echo "body=$BODY_ESC" >> $GITHUB_OUTPUT

      # 4.5 寄送 Email（SMTP 可由 inputs 或 Secrets 提供）
      - name: Send email with AI result
        if: ${{ inputs.email_send_result == 'true' }}
        uses: dawidd6/action-send-mail@v3
        with:
          # 伺服器與認證：inputs 優先，否則用 secrets（方便集中在此模板設定）
          server_address: ${{ inputs.smtp_server != '' && inputs.smtp_server || secrets.SMTP_SERVER }}
          server_port: ${{ inputs.smtp_port != '' && inputs.smtp_port || secrets.SMTP_PORT }}
          username: ${{ inputs.smtp_user != '' && inputs.smtp_user || secrets.SMTP_USER }}
          password: ${{ inputs.smtp_pass != '' && inputs.smtp_pass || secrets.SMTP_PASS }}
          # 收件人：若有自動解析結果，優先使用；否則用 inputs.email_to（可為多位，以逗號分隔）
          to: ${{ steps.email_to.outputs.to != '' && steps.email_to.outputs.to || inputs.email_to }}
          from: ${{ inputs.email_from_override != '' && inputs.email_from_override || (inputs.smtp_from != '' && inputs.smtp_from || secrets.SMTP_FROM) }}
          subject: "${{ format('{0}: {1}@{2}', inputs.email_subject_prefix, github.repository, github.sha) }}"
          content_type: text/markdown
          body: ${{ steps.email_md.outputs.body }}
          attachments: ${{ steps.attachments.outputs.list }}

      # 4.6 Optional fail policy as a dedicated step
      - name: Fail on violations (optional gate)
        if: ${{ inputs.ai_fail_on_violation == 'true' }}
        run: |
          CRIT_COUNT=$(jq '[.violations[] | select(.severity=="critical")] | length' ai-result.json 2>/dev/null || echo 0)
          MAJOR_COUNT=$(jq '[.violations[] | select(.severity=="major")] | length' ai-result.json 2>/dev/null || echo 0)
          MINOR_COUNT=$(jq '[.violations[] | select(.severity=="minor")] | length' ai-result.json 2>/dev/null || echo 0)
          MIN_SEV='${{ inputs.ai_fail_min_severity }}'
          case "$MIN_SEV" in
            critical)
              THRESHOLD=$CRIT_COUNT ;;
            major)
              THRESHOLD=$((CRIT_COUNT + MAJOR_COUNT)) ;;
            minor)
              THRESHOLD=$((CRIT_COUNT + MAJOR_COUNT + MINOR_COUNT)) ;;
            *)
              THRESHOLD=$((CRIT_COUNT + MAJOR_COUNT)) ;;
          esac
          if [ "$THRESHOLD" -gt 0 ]; then
            echo "[ai-review] Failing due to violations (threshold=$MIN_SEV)." >&2
            exit 2
          fi
